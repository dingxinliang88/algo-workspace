package core.unionfind;

import java.util.Arrays;

/**
 * https://leetcode.cn/problems/minimize-malware-spread-ii/
 */
public class MinimizeMalwareSpreadII {

    public static final int MAXN = 301;

    public static final int[] father = new int[MAXN];
    public static final int[] size = new int[MAXN];
    /**
     * 记录每个源头点删掉之后可以拯救多少点的数据
     */
    public static final int[] cnts = new int[MAXN];
    /**
     * 集合的标签: 集合的感染点是什么点
     * 若 a 是代表点，则整个集合源头是 infect[a]
     * 
     * infect[a] == -1, 目前这个集合没有发现源头
     * infect[a] >= 0, 目前这个集合源头是 infect[a]
     * infect[a] == -2, 目前这个集合源头不止一个，已经无法拯救了!
     */
    public static final int[] infect = new int[MAXN];
    /**
     * 标记病毒源头点
     */
    public static final boolean[] virus = new boolean[MAXN];

    public static void build(int n, int[] initial) {
        for (int i = 0; i < n; i++) {
            father[i] = i;
            size[i] = 1;
            cnts[i] = 0;
            infect[i] = -1;
            virus[i] = false;
        }
        for (int i : initial) {
            virus[i] = true;
        }
    }

    public static int find(int i) {
        if (i != father[i]) {
            father[i] = find(father[i]);
        }
        return father[i];
    }

    public static void union(int x, int y) {
        int fx = find(x);
        int fy = find(y);
        if (fx != fy) {
            father[fx] = fy;
            size[fy] += size[fx];
        }
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        build(n, initial);

        // 普通点合并
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1 && !virus[i] && !virus[j]) {
                    union(i, j);
                }
            }
        }

        // 每个集合设置连接的源头点
        for (int sick : initial) {
            for (int i = 0; i < n; i++) { // neighbor
                if (sick != i && !virus[i] && graph[sick][i] == 1) {
                    int fn = find(i);
                    if (infect[fn] == -1) {
                        infect[fn] = sick;
                    } else if (infect[fn] != -2 && infect[fn] != sick) {
                        infect[fn] = -2;
                    }
                }
            }
        }

        // 统计删除每个源头点后可以拯救的节点
        for (int i = 0; i < n; i++) {
            if (i == find(i) && infect[i] > 0) {
                cnts[infect[i]] += size[i];
            }
        }

        // 按照索引从小到大
        Arrays.sort(initial);
        int ans = initial[0], max = cnts[ans];
        for (int i : initial) {
            if (cnts[i] > max) {
                max = cnts[i];
                ans = i;
            }
        }
        return ans;
    }

}
